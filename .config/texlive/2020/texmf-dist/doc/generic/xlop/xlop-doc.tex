\documentclass[12pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{fourier}
\usepackage[scaled]{helvet}
\usepackage[scaled]{luximono}
\usepackage{makeidx}
\usepackage{longtable}
\usepackage{multicol}
\usepackage{pst-node}
\usepackage{fancyvrb-ex}
\usepackage{geometry}
\usepackage{xlop}
\usepackage[english]{babel}
\usepackage[autolanguage]{numprint}
\usepackage{dcolumn}
\usepackage{hyperref}
\usepackage{microtype}

\fvset{label=source}% english

\newcommand*\boi{\textbackslash}
\newcommand*\at{@}

\fvset{xrightmargin=5cm,frame=single,fontsize=\small}
\geometry{a4paper,left=4cm,right=4cm,top=3cm,bottom=3cm,nohead}

\let\SBSori\SideBySideExample
\def\SideBySideExample{%
  \par\bigbreak\SBSori
}
\let\endSBSori\endSideBySideExample
\def\endSideBySideExample{%
  \endSBSori
  \par\bigskip\noindent
}

\newenvironment{syntaxBNF}{%
  \catcode`\_=12
  \def\*##1*{$\langle$##1$\rangle$}%
  \def\alt{\unskip~$|$~\ignorespaces}%
  \def\sameline{\multicolumn{1}{c}{} & \null\quad}%
  \ttfamily
  \begin{center}\begin{tabular}{r@{\quad:=\quad}l}}
{\end{tabular}\end{center}}

\setlongtables
\newcommand\package[1]{\textsf{#1}}
\newcommand\file[1]{\texttt{#1}}

\newcommand\macro[1]{\texttt{$\backslash$#1}\index{#1@\texttt{\boi {#1}}}}
\newcommand\parameter[1]{\texttt{#1}\index{#1@\texttt{#1}}%
  \index{parameter!\texttt{#1}}}

\newcommand\bull{\vrule width3pt height4pt depth-1pt}

\newcounter{stuff}
\makeindex

\begin{document}
\begin{titlepage}
  \null\par\vfill
  \begin{center}
    \begin{minipage}{0.75\linewidth}
      \hrule width\linewidth height2pt depth0pt
      \hrule width0pt height3pt depth0pt
      \hrule width\linewidth height1pt depth0pt
      \hrule width0pt height18pt depth0pt
      \begin{center}
        \Huge\bfseries XLOP v \fileversion\par\vskip18pt
        User Manual
      \end{center}
      \hrule width0pt height6pt depth0pt
      \hrule width\linewidth height1pt depth0pt
      \hrule width0pt height3pt depth0pt
      \hrule width\linewidth height2pt depth0pt
    \end{minipage}
  \end{center}
  \vfill
  \begin{center}
    Jean-Côme Charpentier\\
    \today
  \end{center}
  \vfill\null\par
\end{titlepage}
\newpage
\pagenumbering{roman}
\tableofcontents
\newpage
\pagenumbering{arabic}

\chapter{Overview}
\label{chap:Présentation}
The \package{xlop} package is intended to make automatic arithmetic
operations on arbitrary sized numbers and to display result either on
display mode or inline mode. Here is a first exemple for an overview
of the syntax:
\begin{SideBySideExample}
  \opadd{45,05}{78,4}
\end{SideBySideExample}
We comment this first example in order to give an idea about how use
\package{xlop}.
Addition is displayed ``like in school'': this is the default
displaying. We have an alignment on dots (operand's dot and result's
dot), operator symbol is put on the left and it is vertically centered
between the operands, and the decimal separator is a dot even though we
have specified operands with comma. Finally, note that there is a
carry above the first operand.

Alignment on dot is obligatory. The other points above are deal with
options. Many macros accept an optional argument which controls some
aspects of displaying or computing operation. For that, we use a
``keyval-like'' syntax: we specify a sequence of parameter's
modifications through an affectation's comma separated sequence. One
affectation has one of the two possible syntax below:
\begin{verbatim}
  <parameter>=<value>
  <parameter>
\end{verbatim}
the second one is a shorthand for:
\begin{verbatim}
  <parameter>=true
\end{verbatim}
In this affectation sequence, we can put space(s) after comma. But
don't put space around the equal sign nor before comma: if you put
space(s) here, that means that parameter name or value has a space.

So, if you want a comma as decimal separator , an operator symbol side
by side with the second operand, and no carry, you have just to say:
\begin{SideBySideExample}
  \opadd[decimalsepsymbol={,},
    voperator=bottom,
    carryadd=false]{45.05}{78.4}
\end{SideBySideExample}
Note the trick which consists to put the comma between braces in the
decimal separator symbol definition. In fact, if you say:
\begin{Verbatim}[xrightmargin=0pt]
  \opadd[decimalsepsymbol=,,voperator=bottom,
         carryadd=false]{45.05}{78.4}
\end{Verbatim}
\package{xlop} drives mad! It don't understand what is this sort of
list!

Another important point, though it is less apparent, is that the
figures are put in very precise places. Each figure is put in a box of
fixed width and fixed height (user can change these values), decimal
separator is put in a null-width box (by default), and the lines have
a regular interspace (with or without horizontal rule). This allows
exact spacing and to place what we want where we want.
\begin{SideBySideExample}
  \psset{xunit=\opcolumnwidth,
         yunit=\oplineheight}
  \opadd{45.05}{78.4}
  \oplput(1.5,3){carry}
  \psline{->}(1,3.15)(-3.25,3.15)
\end{SideBySideExample}
This example uses package
\package{pstricks}\index{pstricks@\package{pstricks}}

We have said that \package{xlop} package is able to deal with
arbitrary sized numbers. We come again about this subject and, for
now, we just give an example which shows what is possible. Don't look
at the code, some explanations will be given later in this manual, for
now just admire the result!
\begin{CenterExample}[xrightmargin=0pt]
  \opdiv[style=text,period]{1}{49}
\end{CenterExample}

The package \package{xlop} provides some other features. It is
possible to manipulate numbers through variables. These variables can
be created with an assignation or as a computation result. You can
also manipulate the figures individually:
\begin{SideBySideExample}
  \opadd*{45.05}{78.4}{r}%
  The first figure after dot of
  $45.05+78.4$ is
  \opgetdecimaldigit{r}{1}{d}%
  $\opprint{d}$.
\end{SideBySideExample}
you can make tests:
\begin{SideBySideExample}
  \opadd*{45.05}{78.4}{r}%
  The sum $45.05+78.4$ is
  \opcmp{r}{100}%
  \ifopgt greater than
  \else\ifoplt less than
  \else equal to
  \fi\fi
  $100$.
\end{SideBySideExample}
you can use some operations and some functions:
\begin{SideBySideExample}
  gcd of $182$ and $442$ is
  \opgcd{182}{442}{d}$\opprint{d}$
\end{SideBySideExample}
you can compute complex expression in infix form:
\begin{SideBySideExample}
  \opexpr{(2+3^2)/(gcd(22,33))}{r}%
  $$\frac{2+3^2}{\gcd(22,33)} =
    \opprint{r}$$
\end{SideBySideExample}

\chapter{\package{xlop} Instructions}
Except some macros which will be examined later, the \package{xlop}'s
macros can have an optional argument between brackets in order
to localy modify parameter's values. The other (mandatory) arguments
are (nearly) always numbers. The two sections of this chapter describe
in details what is a number for \package{xlop} and how use parameters.

\section{In the Beginning Was the Number}
\label{sec:Au début etait le nombre}
\subsection{Size}
\label{subsec:Taille}
Before we see the general syntax of number, we examin the very
particular \package{xlop} feature: the ability to deal with arbitrary
sized number.

\index{number!size}To be precise, the theoric maximum size of a number
is $2^{31}-1$ digits\index{number!limit}. In practice, this limit
can't be reached for two essential reasons. The first one is that a
multiplication with two numbers with $2^{25}$~digits needs more than
$7\,000$ years to be performed on the author computer! The second one
is more restrictive because it is linked to \TeX{} stack size limits.
Here is a table showing a \TeX{} compilation for a multiplication with
two operands of same size, on a linux computer, pentium~II~600 and
256~Mb RAM:\footnote{In fact it was the author computer in 2004. The
  actual author computer is \emph{more} powerfull but the author is
  lazy, and he has not remade the tests!}
\begin{center}
  \begin{tabular}{|l|*{6}{c|}}
    \hline
    number of digits & 100 & 200 & 300 & 400 & 425 & 450 \\\hline
    compilation time (s) & 2 & 8 & 18 & 32 & 36 & crash \\\hline
  \end{tabular}
\end{center}
The ``crash'' in the table is due to an overstack for hash table.
\index{hash table}%
\index{overflow}%
On \LaTeX{}, the limit before crash will be reduced. These tests are
made on a minimal file. With a typical document, this limit will be
reduced too. The spool size is another limit quickly reached.
\index{spool size}%
To typeset this document which contain many calls to the
\package{xlop} macros, the author has grown up the spool size
to~$250000$ ($125\,000$ was insufficient) editing the line
\verb+pool_size+ in the \file{texmf.cnf} file. Also, the author has
grown up the hash table to~\texttt{1000} in the line
\verb+hash_extra+.

\subsection{Syntax}
\label{subsec:Syntaxe}
Now we present the syntax using the BNF grammar. There will be human
explanations later:
\begin{syntaxBNF}
  \*number* & \{\*sign*\}\*positive* \alt \*name* \\
  \*sign* & + \alt - \\
  \*positive* & \*integer* \alt \*sep*\*integer* \alt \\
  \sameline \*integer*\*sep* \alt \*integer*\*sep*\*integer* \\
  \*sep* & . \alt , \\
  \*integer* & \*digit*\{\*digit*\} \\
  \*name* & \*start*\{character\} \\
  \*start* & character \textnormal{except } \*sign*\textnormal{,}
  \*sep* \\
  \sameline \textnormal{, and } \*digit*
\end{syntaxBNF}
\index{syntax (BNF)}\index{BNF syntax}

The \texttt{character} symbol means nearly any character accepted by
\TeX{}. The exceptions are characters \verb+%+ and \verb+#+ which are
completely prohibited. In fact, the use of active characters is
risked. For instance, on \LaTeX{}, the \verb+~+ definition prohibits the
use of it inside a variable name. In the other hand, the \verb+\ +is
always the escape char, that is, the variable name will be the name
\emph{after} all is expanded. There isn't any other restraint as the
following code show it:
\begin{SideBySideExample}
  \newcommand\prefix{a/b}
  \opadd*{2}{2}{a/b_{^c}!&$}
  \opprint{\prefix_{^c}!&$}
\end{SideBySideExample}
\index{number!name}%
Note particullary that \verb+a/b_{^c}!&$+ and \verb+\prefix_{^c}!&$+
produce exactly the same name\ldots{} obviously if \verb+\prefix+ has
the right definition! This possibility to have a name using macro
could seem useless but it is not true. For instance, you can realize
loops\index{loop} with names as \verb+r1+, \verb+r2+, \ldots,
\verb+r<n>+ using the code \verb+r\the\cpt+ as variable name, where
\verb+cpt+ is a counter in \TeX{} meaning. With \LaTeX{}, the code
is more verbose with \verb+r\number\value{cpt}+ where \verb+cpt+ is
now a \LaTeX{} counter. We will see an example using this syntax in
the section~\ref{sec:Creation d'operations complexes}
page~\pageref{sec:Creation d'operations complexes}.

\index{number!valid}In practice, what does it mean all these rules?
First, they mean that a number written in a decimal form can be
preceded by any sequence of plus or minus signs. Obviously, if there
is an odd number of minus signs, the number will be negative. Next, a
decimal number admits only one decimal separator symbol which can
be a dot or a comma, this one can be put anywhere in the
number. Finally, a number is write in basis~10. Be carefull: these
rules mean that  \verb+-a+ is not valid.

The package uses some private names and it is safe to not begin a
variable name with the character \texttt{@}.

\section{\package{xlop} Parameters}
\label{sec:Parametres de xlop}
\index{parameter!syntax|(}
Parameter assignments are local to the macro when they are indicated
in the optional argument. To make global a parameter assignment, you
have to use the \macro{opset} macro. For instance:
\begin{Verbatim}[xrightmargin=0pt]
  \opset{decimalsepsymbol={,}}
\end{Verbatim}
gives the comma as decimal separator symbol for the whole document, at
least, until another redefinition with \verb+\opset+.

\subsection{Symbols}
\label{subsecSymboles}
The \parameter{afterperiodsymbol} parameter indicates the symbol that
follows a quotient in line in a division with period
search\index{division!period}. We will see this parameter with the
division. Its default value is \verb+$\ldots$+

The \parameter{equalsymbol} parameter indicates the symbol used for
equality. Its default value is  \verb+$=$+. In fact, this parameter is
defined with:
\begin{Verbatim}[xrightmargin=0pt]
  \opset{equalsymbol={$=$}}
\end{Verbatim}
that is, with braces in order to protect the equal sign. Without
theses braces, there will be a compilation error. You have to process
like that when there is an equal sign or a comma in the
value.\index{parameter!with ``='' or ``,''\quad}

The parameter \parameter{approxsymbol} indicates the symbol used for
approximations. Its default value is \verb+$\approx$+.

The parameter \parameter{decimalsepsymbol} indicates the symbol used
for the decimal separator. Its default value is a dot.

Parameters \parameter{addsymbol}, \parameter{subsymbol},
\parameter{mulsymbol}, and \parameter{divsymbol} indicate the symbols
used for the four arithmetic operations. The default value are
\verb!$+$!, \verb!$-$!, \verb!$\times$! et \verb!$\div$! respectively.

\subsection{General Displaying}
\label{subsec:Presentation generale}
The \parameter{voperation} parameter indicates the way a dispayed
operation is put with respect to the baseline. The possible values are
\verb+top+, \verb+center+, and \verb+bottom+, the latter one is the
default value.
\begin{SideBySideExample}
  top\quad
  \opadd[voperation=top]{45}{172}

  center\quad
  \opadd[voperation=center]{45}{172}

  bottom\quad
  \opadd[voperation=bottom]{45}{172}
\end{SideBySideExample}

The \parameter{voperator} parameter indicates how the operator symbol
is put with repect to operands. The possible values are \verb+top+,
\verb+center+ (default value), and \verb+bottom+.
\begin{SideBySideExample}
  top\quad
  \opadd[voperator=top]{45}{172}
  
  center\quad
  \opadd[voperator=center]{45}{172}
  
  bottom\quad
  \opadd[voperator=bottom]{45}{172}
\end{SideBySideExample}

The \parameter{deletezero} parameter indicates if numbers in
operation should be displayed with or whithout non-significant
zeros. Exact rôle of this parameter depends of the actual
operation. We will see that when we will study the different
operations.

The \parameter{style} parameter indicates the way an operation is
displayed: display with \verb+display+ value (default value) or inline
with \verb+text+ value. We will see when we will study division
because there is many possibilities with this operation.
\begin{SideBySideExample}
  \opadd[style=text]{45}{172}
\end{SideBySideExample}
In inline operations, \package{xlop} takes care to not typeset the
formula in mathematic mode in a direct way. This allow to specify what
you want as in the next example, and it is also for that that you have
to specify the classical values of symbols between mathematic
delimiters.
\begin{SideBySideExample}
  \opadd[addsymbol=plus,
         equalsymbol=equal,
         style=text]{42}{172}
\end{SideBySideExample}
Meanwhile, \package{xlop} introduces exactly the same penalities and
the same spaces as for a mathematic formula.

The \parameter{parenthesisnegative} parameter indicates how to typeset
negative numbers in inline operations. The possible values are:
\begin{itemize}
\item \texttt{none} which typesets negative numbers without
  parenthesis;
\item \texttt{all} which typesets negative numbers with parenthesis;
\item \texttt{last} which typesets negative numbers with parenthesis
  but the first one.
\end{itemize}
\begin{SideBySideExample}
  \opadd[style=text,
         parenthesisnegative=none]
         {-12}{-23}\par
  \opadd[style=text,
         parenthesisnegative=all]
         {-12}{-23}\par
  \opadd[style=text,
         parenthesisnegative=last]
         {-12}{-23}
\end{SideBySideExample}

\subsection{Dimensions}
\label{subsec:Dimensions}
In displayed operations, figures are put in fixed size boxes. The
width and height are given by the \parameter{lineheight}
and \parameter{lineheight} parameters. The default value of
\texttt{lineheight} is \verb+\baselineskip+, that is, the interline
space in operation is the same (by default) as in the normal text. The
default value for \texttt{columnwidth} is \texttt{2ex} because the
``normal'' width of figures would give bad results.
\begin{SideBySideExample}
  \opadd[columnwidth=0.5em]
        {45.89}{127.5}
\end{SideBySideExample}
One reason for this bad result is that the decimal separator is put in
a box which width is controlled by the \parameter{decimalsepwidth}
parameter and the default value of this parameter is null. You can
improve this presentation giving a ``normal'' width to the dot.
\begin{SideBySideExample}
  \opadd[columnwidth=0.5em,
         decimalsepwidth=0.27778em]
        {45.89}{127.5}
\end{SideBySideExample}
It is better but it is dangerous to give a positive width to the box
which contains the decimal separator. It will be more difficult to
place extern object and it is counter against the idea to have a fixed
grid. You should avoid this in normal time.

The \parameter{columnwidth} and \parameter{lineheight} parameters
correspond to the only dimensions that \package{xlop} provides as
public ones, that is,
\verb+\opcolumnwidth+\index{opcolumnwidth@\texttt{$\backslash$opcolumnwidth}}
and
\verb+\oplineheight+\index{oplineheight@\texttt{$\backslash$oplineheight}}
respectively. It is dangerous to directly modify these dimensions
since a modification in a ``normal'' way doesn't only change the
dimension value. Package \package{xlop} make these dimensions public
only for reading, not for writting.

The two next parameters allow to specify width of horizontal and
vertical rules stroked by \package{xlop}. We have
\parameter{hrulewidth} and \parameter{vrulewidth} parameters. The
default values are both \texttt{0.4pt}.

These rules are typeset with no change on grid. That is, with no space
added. Therefore, with great values for thickness, the rules could
run over numbers.
\begin{SideBySideExample}
  \opadd[hrulewidth=8pt]{42}{172}
\end{SideBySideExample}

There is also a parameter which allows to control the horizontal shift
of decimal separator. It is the \parameter{decimalsepoffset} parameter
with a default value of~\texttt{-0.35}. This value indicates a length
with the unit \verb+\opcolumnwidth+. We will see an example at
section~\ref{sec:Division} page~\pageref{sec:Division}.

\subsection{Figure's Styles}
\label{subsec:Styles des chiffres}
The \package{xlop} package provides five types of numbers and
associates five style parameters:
\begin{itemize}
\item operands with \parameter{operandstyle};
\item result with \parameter{resultstyle};
\item remainders with \parameter{remainderstyle};
\item intermediary numbers with \parameter{intermediarystyle};
\item carries with \parameter{carrystyle}.
\end{itemize}
\begin{SideBySideExample}
  \opadd[operandstyle=\blue,
         resultstyle=\red,
         carrystyle=\scriptsize\green]
         {45.89}{127.5}
\end{SideBySideExample}
Keep in mind that, in this manual, we use
\package{pstricks}\index{pstricks@\package{pstricks}} package.

\index{parameter!index|(}%
In fact, the management of these styles is even more powerfull since
you can distingish different number of a same class. In one operation,
you have several operands, and, possibly several remainders and
several intermediary numbers. You can access to the style of these
numbers adding an index to the matching style.
\begin{SideBySideExample}
  \opadd[operandstyle=\blue,
         operandstyle.1=\lightgray,
         resultstyle=\red,
         carrystyle=\scriptsize\green]
         {45.89}{127.5}  
\end{SideBySideExample}
In this example, we indicate that the first operand must be typesetted
with the \verb+\lightgray+ style. We don't indicate anything for the
second operand, so it takes the basic style for its class. (Then with
\verb+\blue+ style.)

This mechanism is even more powerfull since you can write two levels
index for operands, carries, and intermediary numbers (one level for
result and carry) in order to access to each style figure of these
numbers. To simplify index, a positive index indicates the rank of a
figure in the integer part (right to left order, index~1 is for the
unit figure) and a negative index indicates the rank of a figure in
the decimal part (left to right order, $-1$ is for the tenth figure).
\begin{SideBySideExample}
  \opadd[operandstyle.1.1=\white,
         operandstyle.1.-2=\white,
         operandstyle.2.3=\white,
         resultstyle.2=\white,
         deletezero=false]
         {045.89}{127.50}
\end{SideBySideExample}
You can also use a macro with one parameter as a style.
\begin{SideBySideExample}
  \newcommand\hole[1]{$\bullet$}
  \opadd[operandstyle.1.1=\hole,
         operandstyle.1.-2=\hole,
         operandstyle.2.3=\hole,
         resultstyle.2=\hole]
         {45.89}{127.5}
\end{SideBySideExample}
\index{operation!with hole}%
When the style is a macro with argument, this one is the figure. Here
is a more complicated example using \package{pst-node} package of the
\package{pstricks} bundle:
\begin{SideBySideExample}
  \newcommand\OPoval[3]{%
    \dimen1=#2\opcolumnwidth
    \ovalnode{#1}
      {\kern\dimen1 #3\kern\dimen1}}
  \opadd[voperation=top,
    operandstyle.1.1=\OPoval{A}{0},
    operandstyle.2.2=\OPoval{C}{0.8}]
    {45}{172}\qquad
  \begin{minipage}[t]{2cm}
    \pnode(0,0.2em){B}\ figure
    \ncarc{->}{A}{B}\par
    \pnode(0,0.2em){D}\ number
    \ncarc{<-}{D}{C}
  \end{minipage}
\end{SideBySideExample}
As for figures, the decimal separator take account to number style. To
access individually to the decimal separator style, you have to use
\texttt{d} index, numeric indexes are for figures.
\begin{SideBySideExample}
  \newcommand\hole[1]{\texttt{\_}}
  \opmul[intermediarystyle=\hole,
    resultstyle=\hole,
    resultstyle.d=\white]{2.46}{35.7}
\end{SideBySideExample}
\index{parameter!index|)}%
\index{parameter!syntax|)}

\chapter{Arithmetic Operations}
\label{chap:Opérations arithmétiques}
\section{Addition}
\label{sec:Addition}
Addition is deal by the \macro{opadd} macro. When it is in display
mode, it display only nonnegative numbers. Then, it displays a
substraction when one of the operands is nonpositive.%
\index{number!nonpositive in displayed operation}
\begin{SideBySideExample}
  \opadd{-245}{72}
\end{SideBySideExample}
In a general manner, the principle is to display the operation that
allows to find the result as you make it ``by hand''. On the contrary,
the inline mode shows always an addition since we can now write
nonpositive numbers.
\begin{SideBySideExample}
  \opadd[style=text]{-245}{72}
\end{SideBySideExample}
In addition to the general parameters discussed in the
section~\ref{sec:Parametres de xlop}, the macro \verb+\opadd+ uses
parameters \texttt{carryadd}, \texttt{lastcarry}, and
\texttt{deletezero}.

The \parameter{carryadd} parameter is a boolean
parameter\index{parameter!boolean}, that is, it accepts only the
values \texttt{true} and \texttt{false}. By habit, when you don't
specify the value and the equal sign, that is like assignment
\texttt{=true}. This parameter indicates if the carries must be showed
or not. Its default value is \texttt{true}.

The \parameter{lastcarry} parameter is also a boolean parameter. It
indicates if a carry without matching digit for the two operands must
be showed or not. Its default value is \texttt{false}. Take care to
the exact rôle of this parameter. For instance, if the second operand
in the following example is~15307, the last carry would be showed for
any value of the \texttt{lastcarry} parameter since there is a
matching digit in the second operand.
\begin{SideBySideExample}
  \opadd{4825}{5307}
\end{SideBySideExample}
\begin{SideBySideExample}
  \opadd[carryadd=false]{4825}{5307}
\end{SideBySideExample}
\begin{SideBySideExample}
  \opadd[lastcarry]{4825}{5307}
\end{SideBySideExample}

The \parameter{deletezero} parameter is also a boolean parameter. It
indicates if non-significant zeros must be deleted or not. Its default
value is \texttt{true}. When this parameter is \texttt{false}, the
operands and the result has the same number of digits. For that,
\package{xlop} package adds non-significant zeros. Also, the
non-significant zeros of operands are not removed.
\begin{SideBySideExample}
  \opadd{012.3427}{5.2773}
  
  \opadd[deletezero=false]
    {012.3427}{5.2773}
\end{SideBySideExample}

This parameter has exactly the same rôle for inline mode than for
displayed mode.
\begin{SideBySideExample}
  \opadd[style=text]{02.8}{1.2}

  \opadd[style=text,
         deletezero=false]{02.8}{1.2}
\end{SideBySideExample}

Version 0.27 adds a \macro{opmanyadd} macro in order to add more than
two operands. There are some limitations:
\begin{itemize}
\item all the operands must be non negative;
\item some parameters are useless, for instance \parameter{style};
\item carries aren't displayed.
\end{itemize}
In the other hand, the \parameter{vmanyoperator} allows to control the
operator signs.

Here is the first example with the basic syntax. The operands must be
enclosed inside braces. The number of arguments is not limited.
\begin{SideBySideExample}
  \opmanyadd{123.4}{3.1416}
            {2.71828}{0.001}
\end{SideBySideExample}

The \macro{opmanyadd} macro accepts the style parameters for operands
and result. About the operand style, the first index is the operand's
place (top to bottom ones) and the second index is the digit of
operand. For instance:
\begin{SideBySideExample}
  \newcommand\R{\color{red}}
  \opmanyadd[operandstyle.2.3=\R,
             operandstyle.3.3=\R,
             resultstyle.3=\R,
             resultstyle.4=\R]
             {12.6}{853.3}{158.1}
\end{SideBySideExample}
This example shows that non significant zeros are discarded. They can
be display with the \parameter{deletezero} parameter at false value:
\begin{SideBySideExample}
  \opmanyadd[deletezero=false]
            {12.6}{853.3}{158.1}
\end{SideBySideExample}

The \macro{opmanyadd} macro uses also the \parameter{voperation}
parameter as for \macro{opadd} macro.

There is a parameter which is specific to \macro{opmanyadd}:
the \parameter{vmanyoperator} one. These parameter allows to
display plus operator in six different ways.
\begin{CenterExample}
  \opmanyadd{1}{12}{123}{1234}\quad
  \opmanyadd[vmanyoperator=center]
            {1}{12}{123}{1234}\quad
  \opmanyadd[vmanyoperator=top]
            {1}{12}{123}{1234}\quad
  \opmanyadd[vmanyoperator=bottom]
            {1}{12}{123}{1234}
\end{CenterExample}
We can see that the default value is center. The values with lowercase
first letter display as many operators than operands minus one. The
same values with upercase first letter display one single plus
operator:
\begin{CenterExample}
  \opmanyadd[vmanyoperator=Center]
            {1}{12}{123}{1234}\quad
  \opmanyadd[vmanyoperator=Top]
            {1}{12}{123}{1234}\quad
  \opmanyadd[vmanyoperator=Bottom]
            {1}{12}{123}{1234}
\end{CenterExample}

\section{Substraction}
\label{sec:soustraction}
Substraction is made by \macro{opsub} macro. In displayed mode, the
substraction shows only nonnegative numbers. For that, it shows an
addition when one operand is nonpositive.
\begin{SideBySideExample}
  \opsub{-245}{72}
\end{SideBySideExample}
In a general way, the principle is to display the operation which
allow to find the result as you make it ``by hand''. On the contrary,
inline mode shows always a substraction since you can now write
nonpositive numbers.
\begin{SideBySideExample}
  \opsub[style=text]{-245}{72}
\end{SideBySideExample}
This principle apply also when the first operand is less than the
second one (positive case). In this case, we have an operand
inversion.
\begin{SideBySideExample}
  \opsub{1.2}{2.45}
\end{SideBySideExample}
Of course, inline operation gives an exact result.
\begin{SideBySideExample}
  \opsub[style=text]{1.2}{2.45}
\end{SideBySideExample}

In addition to general parameters we have seen at
section~\ref{sec:Parametres de xlop}, \verb+\opsub+ takes account of
\texttt{carrysub}, \texttt{lastcarry}, \texttt{offsetcarry},
\texttt{deletezero}, and \texttt{behaviorsub} parameters.

The \parameter{carrysub} parameter is a boolean one which indicates if
carries must be present or not. Its default value is \texttt{false}.
(Remember that the default value of \texttt{carryadd} parameter is
\texttt{true}.)
\begin{SideBySideExample}
  \opsub[carrysub]{1234}{567}
\end{SideBySideExample}

In the last example, you can see that there is no carry above the last
digit of 1234. This is quite common (at least in France). If you want
display this last carry, you have to use the \parameter{lastcarry}
parameter. This parameter does not have the same behavior in
substraction and in addition since here, the last carry is not
displayed when the second operand does not have correspondent
digit. (For addition, last carry is not displayed when \emph{all} the
operands do not have correspondent digit.)
\begin{SideBySideExample}
  \opsub[carrysub,lastcarry]{1234}{567}
\end{SideBySideExample}
Note that, in this case, it is better to set the
\parameter{deletezero} parameter to \texttt{false} in order to have a
nicer result.
\begin{SideBySideExample}
  \opsub[carrysub,
         lastcarry,
         deletezero=false]{1234}{567}
\end{SideBySideExample}

Perhaps it seems to you that showing carries for substraction is a bit
more dense. You can enlarge the figure box with the
\parameter{opcolumnwidth} parameter. You can also indicate the carry
horizontal shift using the \parameter{offsetcarry} parameter. Its
default value is \texttt{-0.35}.
\begin{SideBySideExample}
  \opsub[carrysub,
         lastcarry,
         deletezero=false]{12.34}{5.67}  

  \bigskip
  \opsub[carrysub,
         lastcarry,
         columnwidth=2.5ex,
         offsetcarry=-0.4,
         decimalsepoffset=-3pt,
         deletezero=false]{12.34}{5.67}  
\end{SideBySideExample}

It is possible that a substraction with two positive numbers and with
the first one less than the second one signs an user error. In this
case, and only in this case, the \parameter{behaviorsub} parameter
allows a call to order. The three possible values are:
\begin{itemize}
\item \texttt{silent} which is the default value and which gives the
  result;
\item \texttt{warning} which gives also the result but shows the
  warning message:
\begin{Verbatim}[xrightmargin=0pt,frame=none]
  xlop warning.  Substraction with first operand less than second one
      See documentation for further information.
\end{Verbatim}
\item \texttt{error} which shows the error message:
\begin{Verbatim}[xrightmargin=0pt,frame=none]
  xlop error.  See documentation for further information.
                   Type  H <return>  for immediate help.
  ! Substraction with first operand less than second one.
\end{Verbatim}
  and the operation is not performed.
\end{itemize}

\section{Multiplication}
\label{sec:Multiplication}
The multiplication is under the control of the \macro{opmul} macro.

The parameters we will see below are \texttt{hfactor},
\texttt{displayintermediary}, \texttt{shiftintermediarysymbol}, and
\texttt{deletezero}. We studied the other parameters in
section~\ref{sec:Parametres de xlop}.

The \parameter{shiftintermediarysymbol} parameter indicates what is
the symbol used for showing the shifting of intermediary numbers
(default value is \verb+$\cdot$+). The
\parameter{displayshiftintermediary} parameter can take value
\texttt{shift} (default value) which shows this symbol only for
shifting greater than one level, value \texttt{all} which shows this
symbol for all the shiftings, and the value \texttt{none} which means
that this symbol will be never showed.
\begin{CenterExample}[xrightmargin=0pt]
  \opmul[displayshiftintermediary=shift]{453}{1001205}\qquad
  \opmul[displayshiftintermediary=all]{453}{1001205}\qquad
  \opmul[displayshiftintermediary=none]{453}{1001205}
\end{CenterExample}

In fact, null intermediary numbers are not display because of the
default value \texttt{none} of the \parameter{displayintermediary}
parameter. The value \texttt{all} shows all the intermediary numbers,
even null intermediary numbers.
\begin{SideBySideExample}
  \opmul[displayintermediary=all]
        {453}{1001205}
\end{SideBySideExample}
Note that null intermediary numbers are displayed with the same width
than the first factor width.

The \parameter{displayintermediary} parameter accepts the value
\texttt{nonzero} which means the same than the \texttt{none} value
except when second factor has only one digit.
\begin{CenterExample}[xrightmargin=0pt]
  \opmul{3.14159}{4}\qquad
  \opmul[displayintermediary=nonzero]{3.14159}{4}
\end{CenterExample}

Finally, parameter \parameter{displayintermediary} accepts the value
\texttt{None} which don't display any intermediary numbers in all cases.
\begin{CenterExample}[xrightmargin=0pt]
  \opmul[displayintermediary=None]{453}{1001205}
\end{CenterExample}

The \parameter{hfactor} parameter indicates how align operands. The
default value, \texttt{right}, gives a raggedleft alignment. The
\texttt{decimal} value gives an alignment on dot.
\begin{CenterExample}[xrightmargin=0pt]
  \opmul{3.1416}{12.8}\qquad\opmul[hfactor=decimal]{3.1416}{12.8}
\end{CenterExample}

For displayed multiplication, the \parameter{deletezero} parameter is
only for operands. The result keeps its non-significant zeros since
there are necessary in order to make a correct dot shifting when we
work ``by hand''.
\begin{CenterExample}[xrightmargin=0pt]
  \opmul[deletezero=false]{01.44}{25}\qquad
  \opmul{01.44}{25}
\end{CenterExample}
In the other hand, this parameter has its usual behaviour in inline
multiplication.
\begin{CenterExample}[xrightmargin=0pt]
  \opmul[deletezero=false,style=text]{01.44}{25}\qquad
  \opmul[style=text]{01.44}{25}
\end{CenterExample}

\section{Division}
\label{sec:Division}
The \package{xlop} package deals with ``normal'' division via
\macro{opdiv} macro and with euclidean division via \macro{opidiv}
macro. Division is a very complex operation so it is not strange that
there are many parameters to control it.

Pay attention that the \package{xlop} package v. \fileversion{} is
unable to deal with ``english'' division. In this package version, the
division is the ``french'' one, which is more or less used as it in
some other countries. The \package{xlop} package v. 0.3 will allow
``enlish'' division (and many more feautures).

\subsection{End Control}
\label{subsec:Controle de l'arret}
In the following text, term \emph{step} means the set of process which
allow to get one digit for the quotient. This number of steps is (not
only) under the control of \parameter{maxdivstep},
\parameter{safedivstep}, and \parameter{period} parameters. It is only
partially true because a classical division will stop automatically
when a remainder will be zero, whatever the values of these three
parameters and an euclidean division will stop with an integer quotient
without attention for these three parameters.
\begin{SideBySideExample}
  \opdiv{25}{7}
\end{SideBySideExample}
\begin{SideBySideExample}
  \opidiv{25}{7}
\end{SideBySideExample}
The first example stops because of the value of \parameter{maxdivstep}
which is 10 by default. Pay attention that the maximum step number
could cause strange result when it is too small.
\begin{SideBySideExample}
  \opdiv[maxdivstep=2]{1248}{3}
\end{SideBySideExample}
Clearly, the last result is false. In the other hand, \package{xlop}
package did what we have ask, that is, obtain two digits (maximum) for
the quotient.

The inline mode differ with zero remainder or not and with the type of
division (classical or euclidean).
\begin{SideBySideExample}
  \opdiv[style=text]{3.14}{2}\par
  \opdiv[style=text]{3.14}{3}\par
  \opidiv[style=text]{314}{2}\par
  \opidiv[style=text]{314}{3}
\end{SideBySideExample}
Note the use of \parameter{equalsymbol} or \parameter{approxsymbol}
parameter according to the case. Note also that \package{xlop}
displays results with floor, not with round. We will see how obtain a
round in section~\ref{sec:Operations evoluees}.

For inline mode of \verb+\opdiv+, \package{xlop} take account of
\parameter{maxdivstep}. It means that we can obtain results very false
with too small values of this parametrer and, unlike with display mode
division, inline mode don't allow to understand what is wrong.
\begin{SideBySideExample}
  \opdiv[maxdivstep=2,style=text]
        {1248}{3}
\end{SideBySideExample}
In addition, if the last remainder is zero, we obtain a must:
\begin{SideBySideExample}
  \opdiv[maxdivstep=1,style=text]
        {1208}{3}
\end{SideBySideExample}
because there is no approximation at all!

A classical division can stop with period detection. For that, you
have just to give the value \texttt{true} for the \parameter{period}
parameter\index{division!period}.
\begin{SideBySideExample}
  \opdiv[period]{100}{3}
\end{SideBySideExample}

To avoid comparizons between each remainder with all previous
remainder, \package{xlop} calculates immediatly the period
length. That allows to process only one comparizon for each step, then
to have a much more efficient process.\footnote{Thanks to Olivier
  Viennet about mathematic precisions that allows to implement these
  calculations.} Unfortunately, these calculations are made with
numbers that are directly accesible to \TeX{}. As consequence, you
can't use operand with absolute value greater than
$\left\lfloor\frac{2^{31}-1}{10}\right\rfloor = 214748364$.

In order to avoid too long calculations, \package{xlop} don't process
beyond the value of \parameter{safedivstep} parameter in division with
period. Its default value is~50. However, \package{xlop} package show
this problem. For instance, if you ask for such a division with the
code:
\begin{Verbatim}[xrightmargin=0pt,frame=none]
  \opdiv[period]{1}{289}
\end{Verbatim}
you obtain the warning message:
\begin{Verbatim}[xrightmargin=0pt,frame=none]
  xlop warning.  Period of division is too big (272 > safedivstep).
      Division will stop before reach it.
      See documentation for further information.
\end{Verbatim}
which indicates that this division period is~272 and that it can be
achieved because of the \texttt{safedivstep} value.

The inline mode for division with period has some particularities.
\begin{SideBySideExample}
  \opdiv[period,style=text]{150}{7}
\end{SideBySideExample}
We obtain an equality rather than an approximation, there is a rule
under the period, and there is ellipsis after the period. All these
components can be configured. The equality symbol is given
by the \parameter{equalsymbol} parameter (default value is
\verb+{$=$}+). The rule thickness is given by
the \parameter{hrulewidth} parameter (default value is
\texttt{0.4pt}). The vertical offset of this rule is given
by \parameter{vruleperiod} parameter (default value is \texttt{-0.2})
which indicates a vertical offset taking \verb+\oplineheight+ as
unit. The ellipsis are given by the
parameter \parameter{afterperiodsymbol} (default value
\verb+$\ldots$+).
\begin{SideBySideExample}
  \opdiv[period,style=text,
         equalsymbol=$\approx$,
         hrulewidth=0.2pt,
         vruleperiod=0.7,
         afterperiodsymbol=]
        {150}{7}
\end{SideBySideExample}

\subsection{Other Features}
\label{subsec:Elements supplementaires}
Displayed divisions can include successive substractions which allow
remainder calculations. For \package{xlop}, the numbers which are
substracted are intermediary numbers, so the different ways to
represent substractions use \parameter{displayintermediary} parameter
see for multiplication. The default value, valeur \texttt{none}, don't
display any substraction; the value \texttt{all} displays all the
substractions, and the value \texttt{nonzero} displays substractions
with non-zero numbers
\begin{CenterExample}[xrightmargin=0pt]
  \opdiv[displayintermediary=none,voperation=top]
        {251}{25}\quad
  \opdiv[displayintermediary=nonzero,voperation=top]
        {251}{25}\quad
  \opdiv[displayintermediary=all,voperation=top]
        {251}{25}
\end{CenterExample}

When we write a display division, we can draw a ``bridge'' over the
part of dividend which is taken in count for the first step of
calculation. The \package{xlop} package allow to draw this symbol
thanks to the boolean parameter \parameter{dividendbridge} (default
value is \texttt{false}).
\begin{SideBySideExample}
  \opdiv[dividendbridge]{1254}{30}
\end{SideBySideExample}

\subsection{Non Integer Numbers and Negative Numbers}
\label{subsec:Nombres non entiers et negatifs}
The \parameter{shiftdecimalsep} parameter governs non integer operands
aspect/ Its default value is \texttt{both} which indicates that
decimal separator is shifted in order to obtain integer divisor and
integer dividend. The value \texttt{divisor} indicates that there is
the shifting that allows an integer divisor. The value \texttt{none}
indicates that there isn't any shifting.
\begin{CenterExample}[xrightmargin=0pt]
  \opdiv[shiftdecimalsep=both]{3.456}{25.6}\quad
  \opdiv[shiftdecimalsep=divisor]{3.456}{25.6}\quad
  \opdiv[shiftdecimalsep=none]{3.456}{25.6}
\end{CenterExample}

Parameter \parameter{strikedecimalsepsymbol} gives the symbol used
to show the old place of decimal separator when this one is
shifted. The default value is empty, that is, there isn't any
symbol. This explain why you don't see anything on previous examples.
\begin{CenterExample}[xrightmargin=0pt]
  \opset{strikedecimalsepsymbol={\rlap{,}\rule[-1pt]{3pt}{0.4pt}}}
  \opdiv[shiftdecimalsep=both]{3.456}{25.6}\quad
  \opdiv[shiftdecimalsep=divisor]{3.456}{25.6}\quad
  \opdiv[shiftdecimalsep=none]{3.456}{25.6}
\end{CenterExample}

When there is a non empty symbol for the striked decimal separator, it
is possible to have non-significant zeros in operands.
\begin{SideBySideExample}
  \opdiv[shiftdecimalsep=divisor,
         strikedecimalsepsymbol=%
           \hspace{-3pt}\tiny$\times$]
        {0.03456}{2.56}
\end{SideBySideExample}

We have already seen that \macro{opidiv} macro gives integer
quotient. This is true even with non integer operands. It is somewhere
strange to perform an euclidian division with non integer operands. The
\macro{opidiv} macro will be strict about the
presentation. Parameters \parameter{maxdivstep}, \parameter{safedivstep},
and \parameter{period} haven't any effect, as
for \parameter{shiftdecimalsep} parameter since operands are changed
to integer ones.
\begin{SideBySideExample}
  \opidiv[strikedecimalsepsymbol=%
          \hspace{-3pt}\tiny$\times$]
          {34.57}{7}
\end{SideBySideExample}

When operands are negative, the inline \macro{opidiv} numbers is
different from the displayed \macro{opidiv} ones. Remainder will be
between zero (include) and absolute value of divisor (exclude).
\begin{SideBySideExample}
  \opdiv[style=text]{124}{7}\par
  \opidiv[style=text]{124}{7}\par
  \opidiv[style=text]{124}{-7}\par
  \opidiv[style=text]{-124}{7}\par
  \opidiv[style=text]{-124}{-7}
\end{SideBySideExample}

This condition for remainder is valid even with non integer divisor.
\begin{SideBySideExample}
  \opidiv[style=text]{1.24}{0.7}\par
  \opidiv[style=text]{1.24}{-0.7}\par
  \opidiv[style=text]{-1.24}{0.7}\par
  \opidiv[style=text]{-1.24}{-0.7}
\end{SideBySideExample}

\chapter{Other Commands}
\label{chap:Autres commandes}
\section{Starred Macros}
\label{sec:Macros etoilees}
The five macros seen in previous chapter have a starred version. These
starred macros perform the calculation and don't display
anything. Result is record in a variable given as argument.

Since these commands don't display anything, parameters don't make
sens and aren't allowed for \macro{opadd*}, \macro{opsub*},
\macro{opmul*}, and \macro{opidiv*}. In the other hand,
parameters \parameter{maxdivstep}, \parameter{safedivstep},
and \parameter{period} influence calculations, then \macro{opdiv*}
macro accepts an optional argument to take account of them.
\begin{SideBySideExample}
  \opmul*{2}{2}{a}%
  \opmul*{a}{a}{a}\opmul*{a}{a}{a}%
  \opadd[style=text]{a}{1}
\end{SideBySideExample}
For macros \macro{opdiv} and \macro{opidiv}, there are two extra
arguments to record quotient and final remainder.
\begin{SideBySideExample}
  \opdiv*[maxdivstep=1]{-88}{16}{q}{r}%
  \opmul*{q}{16}{bq}%
  \opmul[style=text]{16}{q}\par
  \opadd[style=text]{bq}{r}
\end{SideBySideExample}

\section{Input-Output}
\label{sec:Entree-sorties}
The \macro{opcopy} macro copies its first argument into its second
one. Then, the first argument is a number write in decimal form or
\emph{via} a variable, whereas the second one is a variable name.

The \macro{opprint} macro displays its argument. The following example
uses the counter \macro{time} which indicates numbers of minutes since
midnight.
\begin{SideBySideExample}
  \opidiv*{\the\time}{60}{h}{m}%
  It is \opprint{h}~hours
  \opprint{m}~minutes
\end{SideBySideExample}
We will see at section~\ref{sec:Comparaisons} how to improve this
example with tests.

The \macro{opdisplay} macro also displays a number but here, each
figure is in a box. The width of this box is given
by \parameter{columnwidth} and the height of this box is given
by \parameter{lineheight}. Style is specified by the first
argument. This macro accepts an optional argument in order to give a
specific style for individual figures.
\begin{SideBySideExample}
  \opdisplay[resultstyle.1=\bfseries,
             resultstyle.-2=\bfseries]
            {resultstyle}{129.192}
\end{SideBySideExample}
Macros \macro{oplput} and \macro{oprput} allow to put anything
anywhere. The syntax of both of them is different from the other ones
of \package{xlop} since the place is indicated with coordinates
between parenthesis. The coordinates use \macro{opcolumnwidth} and
\macro{oplineheight} as units. Then user is able to build his own
``operations''.
\begin{SideBySideExample}
  \psset{xunit=\opcolumnwidth,
    yunit=\oplineheight}%
  \psgrid[subgriddiv=1,gridlabels=7pt,
          griddots=5](0,1)(10,-2)
  \oplput(2,0){Hello}
  \oprput(8,-1){world!}
  $\bullet$
\end{SideBySideExample}
On example above, note that these macros don't move the reference
point. As a precaution, they kill the trailing space and then, there
is no need to protect the end of line with a \verb+%+.

Macros \macro{ophline} and \macro{opvline} complete the previous ones
to give all the tools the user needs to build its own operations.
\macro{ophline} allows to draw a horizontal rule; its length is given
by the parameter after coordinates. \macro{opvline} does the same for
vertical rules. Remember that parameters \parameter{hrulewidth}
and \parameter{vrulewidth} indicate the thickness of these rules.
\begin{CenterExample}[xrightmargin=0pt]
  \par\vspace{2\oplineheight}
  \oplput(1,2){O}\oplput(2,2){N}\oplput(3,2){E}
  \oplput(0,1.5){$+$}
  \oplput(1,1){O}\oplput(2,1){N}\oplput(3,1){E}
  \ophline(0,0.8){4}
  \oplput(1,0){T}\oplput(2,0){W}\oplput(3,0){O}
\end{CenterExample}

Macro \macro{opexport}\refstepcounter{stuff}\label{macro-opexport}
allow to export a number in a macro. It's an extra to version~0.23
which is very usefull to exchange datas between \package{xlop} and the
outside world. The first argument is a number in the \package{xlop}
sense, that is, either a number write with figures, or a variable
name. The number is translated in a form directly acceptable for
\TeX{} and hold in the second argument which should be a macro
name. However, note that decimal separator will be the one specified
by \parameter{decimalsepsymbol} (without its possible braces).
\begin{SideBySideExample}
  \opmul*{5}{3.141592654}{F}
  \opexport{F}{\fivepi}
  \texttt{\meaning\fivepi}
\end{SideBySideExample}
We can use this macro to typeset numbers calculated by \package{xlop}
in an array with a decimal alignment, or to initialize a counter or a
length (don't forget the unit in the last case).

\section{Figures of Numbers}
\label{sec:Chiffres d'un nombre}
Macros \macro{opwidth}, \macro{opintegerwidth}, and
\macro{opdecimalwidth}  indicate number of digits of the whole number,
of its integer part, of its decimal part respectively. The first
argument is the examined number and the second one indicates the
variable where result will be record.
\begin{SideBySideExample}
  \opcopy{123456.1234}{a}%
  \opwidth{a}{na}%
  \opintegerwidth{a}{ia}%
  \opdecimalwidth{a}{da}%
  \opprint{a} is written with
  \opprint{na} figures (\opprint{ia} in
  the integer part and \opprint{da} in
  the decimal part).
\end{SideBySideExample}

Macro \macro{opunzero} delete all the non-significant
zeros\index{non-significant zero} of the number passed as argument.
\begin{SideBySideExample}
  \opcopy{00150.00250}{a}%
  Before : \opprint{a}\par
  \opunzero{a}%
  After : \opprint{a}
\end{SideBySideExample}

Macros \macro{integer} and \macro{opdecimal} give the integer part and
the decimal part of a number respectively.
\index{number!integer part}\index{integer part}%
\index{number!decimal part}\index{decimal part}%
First argument is the number to process, and the second one is the
variable name which hold the result.
\begin{SideBySideExample}
  \opcopy{-37.69911}{a}%
  \opinteger{a}{ia}%
  \opdecimal{a}{da}%
  Integer part: \opprint{ia}\par
  Decimal part: \opprint{da}
\end{SideBySideExample}

Six macros allow to write or read a figure of a number. You can read
or read a figure according to its place in the whole number, or in the
integer part, or in the decimal part. Figures for whole number and for
decimal part are numbered from right to left, figures for integer part
are numbered from left to right. For instance, with the number
1234.56789, the second figure is 8, the second figure of the integer
part is 3, and the second figure of the decimal part is 6. It is now
easy to guess the rôle of the six next macros:
\begin{itemize}
\item \parameter{opgetdigit} ;
\item \parameter{opsetdigit} ;
\item \parameter{opgetintegerdigit} ;
\item \parameter{opsetintegerdigit} ;
\item \parameter{opgetdecimaldigit} ;
\item \parameter{opsetdecimaldigit} ;
\end{itemize}
Syntax is the same for these macros. The first argument is the
processed number (reading or writting), the second one is the index of
the figure, and the third one is the variable name which hold the
result (figure read) or the new figure (changed number). If index is
out of the range, the reading macros give \texttt{0} as result and
writing macros extend the number in order to reach this index (for
that, zero will be created in new slots).

\section{Comparisons}
\label{sec:Comparaisons}
When you want complex macros, often you need to realize tests. For
that,  \package{xlop} gives the macro \macro{opcmp}. The two
arguments are numbers and this macro setup the tests \macro{ifopgt},
\macro{ifopge}, \macro{ifople}, \macro{ifoplt}, \macro{ifopeq}, and
\macro{ifopneq} to indicate that first operand is greater, greater or
equal, less or equal, less, equal, or different to the second operand
respectively.

For technical reasons, \package{xlop} give global definitions for the
six tests above. Then, they are not protected by groups. Since these
tests are used by many \package{xlop} macros, you must \emph{always}
use tests \verb+\ifop...+ immediately after \macro{opcmp}, or, at
least, before any use of a \package{xlop} macro. Otherwise, there will
be bugs hard to fix!

Let's resume the hour display macro see at
section~\ref{sec:Entree-sorties}. But now, we check if argument is
between 0 (include) and 1440 (exclude), then we process tests in order
to know if ``hour'' is plural or not, as for ``minute''.

\begin{CenterExample}[xrightmargin=0pt]
  \newcommand\hour[1]{%
    \opcmp{#1}{0}\ifopge
    \opcmp{#1}{1440}\ifoplt
      \opidiv*{#1}{60}{h}{m}%
      \opprint{h} hour%
      \opcmp{h}{1}\ifopgt
        s%
      \fi
      \opcmp{m}{0}\ifopneq
        \space\opprint{m} minute%
        \opcmp{m}{1}\ifopgt
          s%
        \fi
      \fi
    \fi\fi
  }
  \hour{60} -- \hour{1080} -- \hour{1081} -- \hour{1082}
\end{CenterExample}

\section{Advanced Operations}
\label{sec:Operations evoluees}
The macros left to be examined are either internal macros and which it
will be a shame to keep private , or macro asked for users.

Internal macros are \macro{opgcd}\index{gcd} which gives gcd of two
numbers and macro \macro{opdivperiod}\index{division!period} which
gives the period length of quotient of two numbers. For efficiency
reason, these macros don't use \package{xlop} number, they rather use
numbers directly understand by \TeX{}. There are two consequences: the
numbers can't be greater than \texttt{2147483647} for \macro{opgcd};
it can't be greater than \texttt{214748364} for
\macro{opdivperiod}. A warning is displayed for an overflow. Result is
put in the third parameter.

There is also some checks on the two first parameters: a gcd must not
have null argument; length of period can't be processed with null
quotient. Futhermore, if an argument is a non integer number, only the
integer part will be take account.
\begin{SideBySideExample}
  \opcopy{5376}{a}%
  \opcopy{2304}{b}%
  \opgcd{a}{b}{gcd(ab)}%
  $\gcd(\opprint{a},\opprint{b}) =
    \opprint{gcd(ab)}$
\end{SideBySideExample}
You can play and find long period of divisions. Without going into
mathematical details, square of prime numbers are good choices. For
instance with $257^2=66049$ you obtain:
\begin{SideBySideExample}
  \opdivperiod{1}{66049}{p}%
  $\frac{1}{66049}$ has a period
  of length $\opprint{p}$.
\end{SideBySideExample}

With macros \macro{opcastingoutnines}\index{casting out of nines} and
\macro{opcastingoutelevens}\index{casting out of elevens} you can
build casting out of nines and casting out of elevens.  \package{xlop}
don't typeset directly these ``operations'' since they need diagonal
rules, and then, need some particular packages. In fact, macro
\macro{opcastingoutnines} calculates the sum modulo~9 of first
argument digits and put the result in second argument. Macro
\macro{opcastingoutelevens} calculates the sum modulo~11 of the even
rank digits of first argument, calculates the sum moldulo~11 of the
odd rank digits of first argument, and calculates the difference of
these two sums.
\begin{SideBySideExample}
  \newcommand\castingoutnines[3]{%
    \opcastingoutnines{#1}{cna}%
    \opcastingoutnines{#2}{cnb}%
    \opmul*{cna}{cnb}{cna*cnb}
    \opcastingoutnines{cna*cnb}{cna*cnb}%
    \opcastingoutnines{#3}{cn(a*b)}%
    \begin{pspicture}(-3.5ex,-3.5ex)%
                     (3.5ex,3.5ex)
      \psline(-3.5ex,-3.5ex)(3.5ex,3.5ex)
      \psline(-3.5ex,3.5ex)(3.5ex,-3.5ex)
      \rput(-2.75ex,0){\opprint{cna}}
      \rput(2.75ex,0){\opprint{cnb}}
      \rput(0,2.75ex){\opprint{cna*cnb}}
      \rput(0,-2.75ex){\opprint{cn(a*b)}}
    \end{pspicture}
  }
  \castingoutnines{157}{317}{49669}
\end{SideBySideExample}
In passing, this example shows that $157\times317\neq49669$! The right
operation is \opmul[style=text]{157}{317}.

The two next macros are very simple. We have \macro{opneg} which
calculates the opposite of its first argument and store it in the
variable indicated by the second argument. We have also \macro{opabs}
which does the same with absolute value.

Macro \macro{oppower} calculates integer powers of numbers. This macro
has three parameters. The third one store the first argument to the
power of the second argument. When the first argument is zero: if the
second argument is zero, result is~1; if the second argument is
positive, result is~0; if the second argument is negative, there is an
error. There isn't any limitation on first parameter. This leads to
some problems, for instance:
\begin{CenterExample}[xrightmargin=0pt]
  \opcopy{0.8}{a}\opcopy{-17}{n}%
  \oppower{a}{n}{r}%
  $\opprint{a}^{\opprint{n}} = \opprint{r}$
\end{CenterExample}
With $0.7$ rather than $0.8$, problem is worse:
\begin{CenterExample}[xrightmargin=0pt]
  \opcopy{0.7}{a}\opcopy{-8}{n}%
  \oppower{a}{n}{r}%
  \opdecimalwidth{r}{dr}
  $\opprint{a}^{\opprint{n}}$ has \opprint{dr}
  figures after dot.
\end{CenterExample}
In fact, when exponent is negative, \emph{first} \package{xlop}
calulates inverse of the number and \emph{after that}, it calculates
the power with opposite of the exponent. In this example, if we had
left $-17$ rather than $-8$, then there will be a capacity overflow
capacity of \TeX{}.

Three macros allow a control about precision. They allow to
approximate a number giving the rank of the approximation. There are
\macro{opfloor}, \macro{opceil}, and \macro{opround}. They need three
parameters which are (in order): start number, rank of approximation,
variable name to store the result.

Rank is an integer value giving number of digits after decimal
separator which must be present. If this rank is negative,
approximation will be done before the decimal separator. If rank
is positive and indicates more digits than decimal part has, then
zeros will be added. If rank is negative and indicates more digits
than integer part has, then approximation will be locked in order to
give the first digit of the number at least.

Here is a summary table which allow to understand how these macros
work.
\begin{center}
  \opcopy{3838.3838}{a}
  \begin{tabular}{|r|l|l|l|}
    \hline
    \multicolumn{4}{|c|}{\textbf{\texttt{\textbackslash
          op\ldots{}\{3838.3838\}\{n\}\{r\}}}}\\\hline
    \multicolumn{1}{|c|}{\textbf{\texttt{n}}} &
    \multicolumn{1}{c|}{\textbf{\texttt{floor}}} &
    \multicolumn{1}{c|}{\textbf{\texttt{ceil}}} &
    \multicolumn{1}{c|}{\textbf{\texttt{round}}} \\\hline
    \opcopy{6}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{4}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{3}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{0}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{-1}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{-2}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{-6}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\\hline
  \end{tabular}
  \opcopy{-3838.3838}{a}
  \begin{tabular}{|r|l|l|l|}
    \hline
    \multicolumn{4}{|c|}{\textbf{\texttt{\textbackslash
          op\ldots{}\{-3838.3838\}\{n\}\{r\}}}}\\\hline
    \multicolumn{1}{|c|}{\textbf{\texttt{n}}} &
    \multicolumn{1}{c|}{\textbf{\texttt{floor}}} &
    \multicolumn{1}{c|}{\textbf{\texttt{ceil}}} &
    \multicolumn{1}{c|}{\textbf{\texttt{round}}} \\\hline
    \opcopy{6}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{4}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{3}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{0}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{-1}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{-2}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\
    \opcopy{-6}{n}$\opprint{n}$ &
    \opfloor{a}{n}{r}$\opprint{r}$ &
    \opceil{a}{n}{r}$\opprint{r}$ &
    \opround{a}{n}{r}$\opprint{r}$ \\\hline
  \end{tabular}
\end{center}

\index{square root}
With version~0.26 comes the square root operation:
\macro{opsqrt}. This macro has not the same syntax as the other
arithmetic macros since there is no starred version. In fact, there is
a way to display a processing of square root but it's really not
current. I'm pretty old and my grandfather told me that he saw
this method when he was young! Therefore, there is an \macro{opgfsqrt}
macro to display the operation (``gf'' for grandfather).

Let us see the first macro: the one which calculates the square root
and store the result in a xlop variable:
\begin{SideBySideExample}
  \opsqrt{2}{sqrt2}
  $\sqrt{2}\approx\opprint{sqrt2}$
\end{SideBySideExample}
This macro shares the parameter \parameter{maxdivstep} with division
macros. For instance:
\begin{SideBySideExample}
  \opsqrt[maxdivstep=15]{2}{sqrt2}
  $\sqrt{2}\approx\opprint{sqrt2}$
\end{SideBySideExample}

For ``grandfather'' display, I have not the energy to explain the
processus. It's based on remarkable identity
$(a+b)^2=a^2+2ab+b^2$. Thanks to Jean-Michel Sarlat who had taken time
to explain this method in order that I can write it for
\package{xlop}!

Here is an example for square root of 15:
\begin{CenterExample}
  \opgfsqrt[maxdivstep=5]{15}
\end{CenterExample}
This method is horrible. It's horrible for human being. It's horrible
for computer. For instance, the real operation isn't make that way:
it uses Heron method.

\index{complex expression|(}
The very last macro we have to study is \macro{opexpr}. It calculates
a complex expression. This macro needs two parameters: the first one
is the expression in infix form (the natural one for human), the
second one is the variable name where the result is stored.

Initially, expression must have been polish one (for instance,
notation used on old HP calculator, or PostScript language), but
another work with Christophe Jorssen has given the actual form for
expression in \package{xlop}, more pleasant for users.

Formulas accept usual arithmetic operators \texttt{+}, \texttt{-},
\texttt{*}, and \texttt{/}. They accept also \texttt{:} operator for
euclidian division, and  \verb+^+ for power. The \texttt{-} operator
has both rôle of substraction and unary operator for opposite. The
\texttt{+} has also these rôles, here the unary operator do\dots{}
nothing! Operands are written in decimal form or \emph{via} variable
name. However, \macro{opexpr} introduces a restriction about variable
name since variable names must be different to function names
recognized by \macro{opexpr}. Accessible functions are:
\begin{itemize}
\item \texttt{abs(a)} ;
\item \texttt{ceil(a,i)} ;
\item \texttt{decimal(a)} ;
\item \texttt{floor(a,i)} ;
\item \texttt{gcd(a,b)} ;
\item \texttt{integer(a)} ;
\item \texttt{mod(a,b)} gives result of \texttt{a} modulo
  \texttt{b} ;
\item \texttt{rest(a,b)} gives remainder of \texttt{a} divide by
  \texttt{b} (difference between remainider and modulo is the same as
  between non euclidian division and euclidian division);
\item \texttt{round(a,i)}.
\end{itemize}
where functions that aren't listed above ask the matching macros.
(function \texttt{xxx} calls macro \verb+\opxxx+) For functions
\texttt{ceil}, \texttt{floor}, and \texttt{round}, the number
\texttt{i} indicates rank for approximation.

Macro \macro{opexpr} accept optional argument since it can realize
division which can be controlled
by \parameter{maxdivstep},\parameter{safedivstep},
and \parameter{period} parameters. Our first example is quite basic:
\begin{CenterExample}[xrightmargin=0pt]
  \opexpr{3--gcd(15*17,25*27)*2}{r}%
  $3--\gcd(15\times17,25\times27)\times2 = \opprint{r}$
\end{CenterExample}

Here is another example that shows that datas can come from a macro:
\begin{CenterExample}[xrightmargin=0pt]
  \newcommand\try{2}%
  \opexpr{\try+1/
    (\try+1/
      (\try+1/
        (\try+1/
          (\try+1/
            (\try)))))}{r}
  Continued fraction of base $u_n=2$ equal \opprint{r} at rank~5.
\end{CenterExample}
\index{complex expression|)}

\appendix
\chapter{Short Summary}
\label{chap:Aide-mémoire}
\section{Compilation times}
\label{sec:Temps de compilation}
Compilation times was measured on a computer with
processor Pentium II 600\,MHz, RAM 256\,MB, on linux system (Debian
woody).\footnote{In fact, these measures was done in 2004, when the
  0.2 version was released. Author is somewhere lasy and he doesn't
  measure with his new computer (more efficient)!}. The principle is
to do a minimal file \texttt{.tex}. The general canvas is:
\begin{verbatim}
  \input xlop
  \count255=0
  \loop
  \ifnum\count255<1000
    <operation to test>
   \advance\count255 by1
  \repeat
  \bye
\end{verbatim}
Compilation time with \verb+<operation to test>+ empty was substract
from the others test. Only the user time was take account. Results are
given in millisecond and should be read with great precautions.

\index{compilation time|(}\index{time (calculation)|(}%
Next table gives operation times in milliseconds. Operands used had
decimal notation but some trails with variable has shown that times
was very closed.

First line indicates the numbers of digits for both operands.
Operands were build like this:
\begin{itemize}
\item $\mathrm{A} = 1$ et $\mathrm{B} = 9$ for one digit;
\item $\mathrm{A} = 12$ et $\mathrm{B} = 98$ for two digits;
\item $\mathrm{A} = 123$ et $\mathrm{B} = 987$ for three digits;
\item $\mathrm{A} = 12345$ et $\mathrm{B} = 98765$ for five digits;
\item $\mathrm{A} = 1234567890$ et $\mathrm{B} = 9876543210$ for ten
  digits;
\item $\mathrm{A} = 12345678901234567890$ et $\mathrm{B} =
  98765432109876543210$ for twenty digits;
\end{itemize}
Here is results, some comments follow:

\bigskip\noindent\hbox to\linewidth{\hss
  \begin{tabular}{|r|*{6}{l|}}
    \cline{2-7}
    \multicolumn{1}{l|}{} &
    \multicolumn{1}{c|}{1} &
    \multicolumn{1}{c|}{2} &
    \multicolumn{1}{c|}{3} &
    \multicolumn{1}{c|}{5} &
    \multicolumn{1}{c|}{10} &
    \multicolumn{1}{c|}{20} \\\hline
    \verb+\opadd*{A}{B}{r}+ &
    1.1 & 1.4 & 1.6 & 2.1 & 3.3 & 5.8 \\\cline{2-7}
    \verb+\opadd*{B}{A}{r}+ &
    1.1 & 1.4 & 1.6 & 2.1 & 3.3 & 5.8 \\\hline
    \verb+\opsub*{A}{B}{r}+ &
    1.7 & 2.1 & 2.4 & 3.0 & 4.8 & 8.3 \\\cline{2-7}
    \verb+\opsub*{B}{A}{r}+ &
    1.5 & 1.7 & 2.0 & 2.6 & 4.0 & 7.0 \\\hline
    \verb+\opmul*{A}{B}{r}+ &
    4.6 & 6.3 & 8.2 & 12.8 & 29.9 & 87.0 \\\cline{2-7}
    \verb+\opmul*{B}{A}{r}+ &
    5.0 & 6.6 & 8.5 & 13.2 & 30.3 & 87.8 \\\hline
    \verb+\opdiv*{A}{B}{q}{r}+ &
    46.4 & 53.8 & 53.8 & 64.3 & 85.8 & 124.7 \\\cline{2-7}
    \verb+\opdiv*{B}{A}{q}{r}+ &
    12.4 & 48.9 & 55.7 & 58.6 & 72.8 & 111.0 \\\hline
    \verb+\opdiv*[maxdivstep=5]{A}{B}{q}{r}+ &
    26.8 & 30.0 & 32.6 & 37.6 & 49.5 & 73.5 \\\cline{2-7}
    \verb+\opdiv*[maxdivstep=5]{B}{A}{q}{r}+ &
    12.4 & 29.1 & 32.6 & 35.2 & 43.3 & 67.9 \\\hline
    \verb+\opidiv*{A}{B}{q}{r}+ &
    10.8 & 12.2 & 13.5 & 16.0 & 22.3 & 35.5 \\\cline{2-7}
    \verb+\opidiv*{B}{A}{q}{r}+ &
    11.6 & 13.0 & 14.2 & 16.6 & 23.0 & 36.7 \\\hline
    \verb+\opidiv*{A}{2}{q}{r}+ &
    10.7 & 12.0 & 15.3 & 22.3 & 42.9 & 83.0 \\\hline
  \end{tabular}
  \hss
}
\par\bigskip
It is normal that inversion of operands don't have sensible influence
for addition. Then, it could be strange that there is influence for
substraction. In fact, when the second operand is bigger than the
second one, there is additional process (double inversion, operation
on the sign of the result).

It is normal that division time is greater than the multiplication
one. It could be abnormal that division seems catch up! In fact, the
multiplication complexity grows quickly with the operand length. In
the other hand, division complexity is stopped
by \parameter{maxdivstep} parameter. It is clear on example where
there is only five steps.

Some results seems odd. For instance \verb+\opdiv*{9}{1}{q}{r}+ is
very fast. These is due to the one digit quotient.
\verb+\opdiv*{123}{987}{q}{r}+, even more odd, is rather fast. Here,
explanation is quite subtle: this is due to many zeros in the
quotient.

When operands have comparable length, euclidian division is much
faster than non euclidian one. This is because quotient has few
digits (only one for all the numbers \texttt{A} and \texttt{B}). The
last line of the table is more relevant for this operation time.

All these remarks are written to put the emphasis on the difficulty to
evaluate the compilation time: it depends on too many parameters. On
the other hand, this table give a pretty good idea of what can be
expected.
\index{compilation time|)}\index{time (calculation)|)}%

\newpage
\section{Macro List}
\label{sec:Liste des macros}
\index{macros!table of|(}%
\noindent\begin{longtable}{|l|p{6.3cm}|}
  \hline
  \multicolumn{1}{|c|}{\textbf{Macro}} &
  \multicolumn{1}{c|}{\textbf{Description}} \\\hline\hline
  \endfirsthead
  \hline
  \multicolumn{1}{|c|}{\textbf{Macro}} &
  \multicolumn{1}{c|}{\textbf{Description}} \\\hline\hline
  \endhead
  \hline
  \multicolumn{2}{|c|}{$\ldots$ to be continued $\ldots$}\\
  \hline
  \endfoot
  \hline
  \endlastfoot
  \verb+\opabs{n}{N}+ &
  \verb+N+ stores the absolute value of \verb+n+. \\\hline
  \verb+\opadd[P]{n1}{n2}+ &
  Displays result of \verb-n1+n2-. \\\hline
  \verb+\opadd*{n1}{n2}{N}+ &
  Calcules \verb-n1+n2- and put result in \verb+N+. \\\hline
  \verb+\opcastingoutelevens{n}{N}+ &
  Calcules difference (modulo 11) of sum of rank odd digits and sum of
  rank even digits of \verb+n+ and put the result in \verb+N+.\\\hline 
  \verb+\opcastingoutnines{n}{N}+. &
  Calcules sum modulo 9 of digits of \verb+n+ and put result in
  \verb+N+. \\\hline
  \verb+\opceil{n}{T}{N}+ &
  Places in \verb+N+ the approximation (ceiling) of \verb+n+ to rank
  \verb+T+. \\\hline
  \verb+\opcmp{n1}{n2}+ &
  Compares numbers \verb+n1+ and \verb+n2+ and setup the tests
  \verb+\ifopeq+, \verb+\ifopneq+, \verb+\ifopgt+, \verb+\ifopge+,
  \verb+\ifople+ et \verb+\ifoplt+. \\\hline
  \verb+\opcopy{n}{N}+ &
  Copy number \verb+n+ in \verb+N+. \\\hline
  \verb+\opdecimal{n}{N}+ &
  Copy decimal part (positive integer number) of \verb+n+ in
  \verb+N+. \\\hline
  \verb+\opdecimalwidth{n}{N}+ &
  \verb+N+ stores the width of decimal part of number \verb+n+.
  \\\hline
  \verb+\opdisplay[P]{S}{n}+ &
  Display number \verb+n+ width style \verb+S+ puting each figure in a
  box which has a width of \verb+\opcolumnwidth+ and a height of
  \verb+\oplineheight+. \\\hline
  \verb+\opdiv[P]{n1}{n2}+ &
  Display result of n1/n2. \\\hline
  \verb+\opdiv*[P]{n1}{n2}{N1}{N2}+ &
  Calculates \verb+n1/n2+, put the quotient in \verb+N1+ and the
  remainder in \verb+N2+. \\\hline
  \verb+\opdivperiod{T1}{T2}{N}+ &
  Calculates length of period of \verb+T1+ divide by \verb+T2+ and put
  the result in \verb+N+. \\\hline
  \verb+\opexport[P]{n}\cmd+ &
  Copy number \verb+n+ in macro \verb+\cmd+. \\\hline
  \verb+\opexpr[P]{F}{N}+ &
  Evaluates formula \texttt{F} and put the final result in
  \texttt{N}. \\\hline
  \verb+\opfloor{n}{T}{N}+ &
  Put in \verb+N+ the apprimation (floor) of \verb+n+ at rank
  \verb+T+. \\\hline
  \verb+\opgcd{T1}{T2}{N}+ &
  Calculates gcd of \verb+T1+ and \verb+T2+ and put result in
  \verb+N+. \\\hline
  \verb+\opgetdecimaldigit{n}{T}{N}+ &
  Build the number \verb+N+ with the only digit in slot 
  \verb+T+ of decimal part of \verb+n+. \\\hline
  \verb+\opgetdigit{n}{T}{N}+ &
  Build the number \verb+N+ with the only digit in slot
  \verb+T+ of number \verb+n+. \\\hline
  \verb+\opgetintegerdigit{n}{T}{N}+ &
  Build the number \verb+N+ width the only digit in slot
  \verb+T+ of integer part of \verb+n+. \\\hline
  \verb+\opgfsqrt{n}+ &
  Display the old timed way to calculate a square root of
  \verb+n+. \\\hline
  \verb+\ophline(T1,T2){T3}+ &
  Draw a horizontal rule of length \verb+T3+, of thickness
  \verb+hrulewidth+, and which begin at \verb+(T1,T2)+ in relation to
  reference point. \\\hline
  \verb+\opidiv[P]{n1}{n2}+ &
  Display the result of \verb+n1/n2+. (euclidian division, that is,
  with integer division) \\\hline
  \verb+\opidiv*{n1}{n2}{N1}{N2}+ &
  Calculates \verb+n1/n2+ (euclidian division), put quotient
  (integer) in \verb+N1+ and remainder (between 0 (include) and
  \verb+|n2|+ (exclude)) in \verb+N2+. \\\hline
  \verb+\opinteger{n}{N}+ &
  Copy integer part (positive integer number) of \verb+n+
  in \verb+N+. \\\hline
  \verb+\opintegerwidth{n}{N}+ &
  Number \verb+N+ stores the width of integer part of number \verb+n+.
  \\\hline
  \verb+\oplput(T1,T2){<object>}+ &
  Put \verb+<object>+ to the right of the point with coordinates
  \verb+(T1,T2)+ in relation to reference point. \\\hline
  \verb+opmanyadd[P]{n1}...{np}+ &
  Display result of $\mathrm{n1}+\cdots+\mathrm{np}$ \\\hline
  \verb+\opmul[P]{n1}{n2}+ &
  Display result of \verb+n1*n2+. \\\hline
  \verb+\opmul*{n1}{n2}{N}+ &
  Calculates \verb+n1*n2+ and put the result in \verb+N+. \\\hline
  \verb+\opneg{n}{N}+ &
  Number \verb+N+ stores opposite of \verb+n+. \\\hline
  \verb+\oppower{n}{T}{N}+ &
  Calculates \verb+n+ to the power of \verb+T+ and put the result in
  \verb+N+. \\\hline
  \verb+\opprint{n}+ &
  Display number \verb+n+ in a direct way. \\\hline
  \verb+\opround{n}{T}{N}+ &
  Put in \verb+N+ the approximation of \verb+n+ at rank \verb+T+.
  \\\hline
  \verb+\oprput(T1,T2){<object>}+ &
  Put \verb+<object>+ to the left of the point with coordinates
  \verb+(T1,T2)+ in relation to reference point. \\\hline
  \verb+\opset{L}+ &
  Allocates globally \package{xlop} parameters given in the list
  \verb+L+. \\\hline
  \verb+\opsetdecimaldigit{n}{T}{N}+ &
  Modify the digit of rank \verb+T+ in decimal part of \verb+N+ in
  order to have the value \verb+n+ for this digit. \\\hline
  \verb+\opsetdigit{n}{T}{N}+ &
  Modify the digit of rank \verb+T+ of \verb+N+ in
  order to have the value \verb+n+ for this digit. \\\hline
  \verb+\opsetintegerdigit{n}{T}{N}+ &
  Modify the digit of rank \verb+T+ in integer part of \verb+N+ in
  order to have the value \verb+n+ for this digit. \\\hline
  \verb+\opsqrt{n}{N}+ & Put square root of \verb+n+ in
  \verb+N+. \\\hline
  \verb+\opsub[P]{n1}{n2}+ &
  Display result of \verb+n1-n2+. \\\hline
  \verb+\opsub*{n1}{n2}{N}+ &
  Calculates \verb+n1-n2+ and put the result in \verb+N+. \\\hline
  \verb+\opunzero{N}+ &
  Delete non-significant zeros of \verb+N+. \\\hline
  \verb+\opvline(T1,T2){T3}+ &
  Draw a vertical ruleof length \verb+T3+, of thickness
  \verb+hrulewidth+ and which begin at \verb+(T1,T2)+ in relation to
  reference point. \\\hline
  \verb+\opwidth{n}{N}+ &
  Number \verb+N+ stores number of digits of number \verb+n+. \\\hline
\end{longtable}\index{macros!table of|)}

In this table, parameters:
\begin{itemize}
\item \texttt{n} and \texttt{ni} (where \texttt{i} is an index)
  indicate that parameter must be a number given in decimal form or a
  variable name;
\item \texttt{N} and \texttt{Ni} (where \texttt{i} is an index)
  indicate that parameter must be a number given in decimal form or a
  variable name;
\item \texttt{[P]} indicates that the macro accept an optional
  parameter which allow to modify parameter of \package{xlop};
\item \texttt{T} and \texttt{Ti} (where \texttt{i} is an index)
  indicate that parameter must be a number given in decimal form or a
  variable name but must be less than numbers acceptable by \TeX{},
  that is, $-2147483648 \le \mathtt{T} \le 2147483647$.
\end{itemize}

\section{Parameter list}
\label{sec:Liste des parametres}
\index{parameter!table of|(}%
\begingroup
\advance\hoffset by-1.75cm \advance\linewidth by1.75cm
\begin{longtable}{|l|l|p{7cm}|}
  \hline
  \multicolumn{1}{|c|}{\textbf{Parameter}} &
  \multicolumn{1}{c|}{\textbf{Default}} &
  \multicolumn{1}{c|}{\textbf{Signification}} \\\hline\hline
  \endfirsthead
  \hline
  \multicolumn{1}{|c|}{\textbf{Parameter}} &
  \multicolumn{1}{c|}{\textbf{Default}} &
  \multicolumn{1}{c|}{\textbf{Signification}} \\\hline\hline
  \endhead
  \hline
  \multicolumn{3}{|c|}{$\ldots$ to be continued $\ldots$}\\
  \hline
  \endfoot
  \hline
  \endlastfoot
  \verb+afterperiodsymbol+ &
  \verb+$\ldots$+ &
  Symbol used after a period of a division. \\\hline 
  \verb+approxsymbol+ &
  \verb+$\approx$+ &
  Symbol used as approximation relation in inline operations. \\\hline
  \verb+equalsymbol+ &
  \verb+{$=$}+ &
  Symbol used as equality relation in inline operations. \\\hline
  \verb+addsymbol+ &
  \verb-$+$- &
  Symbol used as addition operator. \\\hline
  \verb+subsymbol+ &
  \verb+$-$+ &
  Symbol used as substraction operator. \\\hline
  \verb+mulsymbol+ &
  \verb+$\times$+ &
  Symbol used as multiplication operator. \\\hline
  \verb+divsymbol+ &
  \verb+$\div$+ &
  Symbol used as multiplication operator for inline
  operations. \\\hline
  \verb+decimalsepsymbol+ &
  \verb+.+ &
  Symbol used as decimal separator. \\\hline
  \verb+strikedecimalsepsymbol+ &
  &
  Symbol used as decimal separator moved in dividend and divisor for
  display division. \\\hline
  \verb+shiftintermediarysymbol+ &
  \verb+$\cdot$+ &
  Symbol used to show intermediary numbers shifting for display
  multiplication. \\\hline
  \verb+displayshiftintermediary+ &
  \verb+shift+ &
  Indicates that the shifting character for multiplications will be
  displayed only for additional shifting (value \verb+shift+), for
  all the shifting (value \verb+all+), or never (value
  \verb+none+). \\\hline
  \verb+vmanyoperator+ &
  \verb+center+ &
  Vertical alignment for add symbol in displayed many operand
  addition. The value \verb+top+ put operators from the level of first
  operand to the level of second to last operand. The value
  \verb+center+ put operators between operands. The value
  \verb+bottom+ put operators from the level of second operand to the
  level of last operand. The value \verb+Top+ put one single operator
  at the level of first operand. The value \verb+\center+ put one
  single operator at the vertical middle of operands. The value
  \verb+Bottom+ put one single operator at the level of last
  operand. \\\hline
  \verb+voperation+ &
  \verb+bottom+ &
  Vertical alignment for displayed operation. The value \verb+bottom+
  indicates that the bottom of operation will be aligned with
  baseline. The value \verb+top+ indicates that the top of operation
  will be aligned with baseline. The value \verb+center+ indicates
  that operation will be verticaly centred with baseline. \\\hline
  \verb+voperator+ &
  \verb+center+ &
  Vertical alignment for operators in displayed operations. The value
  \verb+top+ put operator at the level of first operand. The value
  \verb+bottom+ put operator at the level of second operand. The value
  \verb+center+ put operator between operands. \\\hline
  \verb+hfactor+ &
  \verb+decimal+ &
  Sort of operands alignment for displayed operation. The value
  \verb+decimal+ indicates an alignment on decimal separator. The
  value \verb+right+ indicates a flushright alignment. \\\hline
  \verb+vruleperiod+ &
  \verb+-0.2+ &
  Vertical position of rule which indicates period of quotient for
  inline division. \\\hline
  \verb+dividendbridge+ &
  \verb+false+ &
  Indicates if there is a ``bridge'' above dividend. \\\hline
  \verb+shiftdecimalsep+ &
  \verb+both+ &
  Indicates how shift decimal separator into operands for a displayed
  division. The value \verb+both+ indicates that shifting are made on
  both divisor and dividend in order to make integer numbers. The
  value \verb+divisor+ indicates that the shifting must give an
  integer divisor. The value \verb+none+ indicates that there is no
  shifting. \\\hline
  \verb+maxdivstep+ &
  \verb+10+ &
  Maximal number of steps in division or in square root
  operation. \\\hline
  \verb+safedivstep+ &
  \verb+50+ &
  Maximal number of steps in division when there is a period to
  reach. \\\hline
  \verb+period+ &
  \verb+false+ &
  Indicates if division must be stoped when a whole period is
  reached. \\\hline
  \verb+deletezero+ &
  \verb+true+ &
  Indicates that non-significant zeros are displayed (\verb+false+) or
  deleted (\verb+true+). \\\hline
  \verb+carryadd+ &
  \verb+true+ &
  Indicates that carries are displayed (\verb+true+) for displayed
  additions. \\\hline
  \verb+carrysub+ &
  \verb+false+ &
  Indicates that carries are displayed (\verb+true+) for displayed
  substractions. \\\hline
  \verb+offsetcarry+ &
  \verb+-0.35+ &
  Horizontal offset for carries into displayed substractions. \\\hline
  \verb+style+ &
  \verb+display+ &
  Indicates tha operation are inline (\verb+text+) or displayed
  (\verb+display+). \\\hline
  \verb+displayintermediary+ &
  \verb+nonzero+ &
  Indicates that all intermediary results are displayed (\verb+all+),
  only non null ones are displayed (\verb+nonzero+), or any
  intermediary result isn't displayed into displayed multiplications
  and divisions. \\\hline
  \verb+lastcarry+ &
  \verb+false+ &
  Indicates that carry with no figure just below it must be displayed
  (\verb+true+), or not (\verb+false+). \\\hline
  \verb+parenthesisnegative+ &
  \verb+none+ &
  Behavior to display negative numbers in inline operations. The value
  \verb+none+ displays them without parenthesis. The value \verb+all+
  displays them always with parenthesis. The value \verb+last+ display
  parenthesis except for first operand of an expression. \\\hline
  \verb+columnwidth+ &
  \verb+2ex+ &
  With of box for one figure. \\\hline
  \verb+lineheight+ &
  \verb+\baselineskip+ &
  Height of box for one figure. \\\hline
  \verb+decimalsepwidth+ &
  \verb+0pt+ &
  Width of box that hold the decimal separator. \\\hline
  \verb+decimalsepoffset+ &
  \verb+0pt+ &
  Horizontal offset for decimal separator. \\\hline
  \verb+hrulewidth+ &
  \verb+0.4pt+ &
  Thickness of horizontal rules. \\\hline
  \verb+vrulewidth+ &
  \verb+0.4pt+ &
  Thickness of vertical rules. \\\hline
  \verb+behaviorsub+ &
  \verb+silent+ &
  \package{xlop} behavior for an ``impossible'' substraction, that is,
  a substraction with two positive operands, the second greater
  than the first one. The value  \verb+silent+ does operation swapping
  the two operands in a slient way. With the value \verb+warning+,
  there are also a swapping but \package{xlop} gives a warning. The
  value \verb+error+ display an error message and operation isn't
  processed. \\\hline
  \verb+country+ &
  \verb+french+ &
  Indicates the displayed operation behavior depending of
  contry. Package \package{xlop} put forward only \verb+french+,
  \verb+american+, and \verb+russian+ but these different ways to
  display operations aren't encoded in version
  \fileversion{}. \\\hline
  \verb+operandstyle+ &
  &
  Style for operands. \\\hline
  \verb+resultstyle+ &
  &
  Style for results. \\\hline
  \verb+remainderstyle+ &
  &
  Style for remainders. \\\hline
  \verb+intermediarystyle+ &
  &
  Style for intermediary results (intermediary numbers in
  multiplication and number to substract in division when successive
  substractions are displayed). \\\hline
  \verb+carrystyle+ &
  \verb+\scriptsize+ &
  Style for carries. The default value when compilation are made
  without \LaTeX{} is \verb+\sevenrm+. \\\hline
\end{longtable}\index{parameter!table of|)}
\endgroup

\chapter{Tricks}
\label{chap:Trucs et astuces}
\section{\package{xlop} vs. \package{calc} and \package{xfp}}
You could believe that \package{xlop} can replace package such
\package{calc}\index{package!calc}\index{calc} and
\package{xfp}\index{package!xfp}\index{xfp}. In fact, that is not so
simple. Obviously \package{xlop} can do complex calculations, on arbitrary
long numbers but, unlike \package{calc}, it don't allow to process
directly dimensions. Comparison with \package{xfp} is somewhere more
realistic but remember that \package{xlop} can make memory usage too
high. In fact \package{xfp} is far more powerfull than \package{xlop}
about pure calmculation!

If you want to process calculations on length\index{length}, you can use
that a dimen register allocation to a counter gives a number which
correspond to this length with unit \texttt{sp}.
\begin{CenterExample}[xrightmargin=0pt]
  \newcommand\getsize[2]{%
    \dimen0=#1\relax
    \count255=\dimen0
    \opcopy{\the\count255}{#2}}
  \getsize{1pt}{r}$1\,\mathrm{pt}=\opprint{r}\,\mathrm{sp}$\quad
  \getsize{1pc}{r}$1\,\mathrm{pc}=\opprint{r}\,\mathrm{sp}$\quad
  \getsize{1in}{r}$1\,\mathrm{in}=\opprint{r}\,\mathrm{sp}$\quad
  \getsize{1bp}{r}$1\,\mathrm{bp}=\opprint{r}\,\mathrm{sp}$\quad
  \getsize{1cm}{r}$1\,\mathrm{cm}=\opprint{r}\,\mathrm{sp}$\quad
  \getsize{1mm}{r}$1\,\mathrm{mm}=\opprint{r}\,\mathrm{sp}$\quad
  \getsize{1dd}{r}$1\,\mathrm{dd}=\opprint{r}\,\mathrm{sp}$\quad
  \getsize{1cc}{r}$1\,\mathrm{cc}=\opprint{r}\,\mathrm{sp}$\quad
  \getsize{1sp}{r}$1\,\mathrm{sp}=\opprint{r}\,\mathrm{sp}$\quad
\end{CenterExample}
However, don't forget that the \package{xlop} main goal is to
\emph{display} operations.

With this \macro{getsize} macro, it is possible to realise
calculations on length. 
\begin{SideBySideExample}
  \newcommand\getsize[2]{%
    \dimen0=#1\relax
    \count255=\dimen0
    \opcopy{\the\count255}{#2}}
  \getsize{1cm}{u}%
  \getsize{\textwidth}{w}%
  \getsize{\textheight}{h}%
  \opexpr{w*h/u^2}{S}%
  \opround{S}{2}{S}%
  Surface of spread is
  \opprint{S}\,$\mathrm{cm}^2$
\end{SideBySideExample}

\section{Complex Operations}
\label{sec:Creation d'operations complexes}
Use of \package{xlop} macros with loop of \TeX{} allow to create
operations as you want. Here, we give only two examples. The first one
can express a number as a product of prime factors, the second one is
a general calculation for continued
fraction.\index{number!prime}\index{loop|(}%
\index{product of prime factors}
\begin{Verbatim}[xrightmargin=0pt]
  \newcount\primeindex
  \newcount\tryindex
  \newif\ifprime
  \newif\ifagain
  \newcommand\getprime[1]{%
    \opcopy{2}{P0}%
    \opcopy{3}{P1}%
    \opcopy{5}{try}
    \primeindex=2
    \loop
      \ifnum\primeindex<#1\relax
      \testprimality
      \ifprime
        \opcopy{try}{P\the\primeindex}%
        \advance\primeindex by1
      \fi
      \opadd*{try}{2}{try}%
      \ifnum\primeindex<#1\relax
        \testprimality
        \ifprime
          \opcopy{try}{P\the\primeindex}%
          \advance\primeindex by1
        \fi
        \opadd*{try}{4}{try}%
      \fi
    \repeat
  }
  \newcommand\testprimality{%
    \begingroup
      \againtrue
      \global\primetrue
      \tryindex=0
      \loop
        \opidiv*{try}{P\the\tryindex}{q}{r}%
        \opcmp{r}{0}%
        \ifopeq \global\primefalse \againfalse \fi
        \opcmp{q}{P\the\tryindex}%
        \ifoplt \againfalse \fi
        \advance\tryindex by1
      \ifagain
      \repeat
    \endgroup
  }
\end{Verbatim}
\newcount\primeindex
\newcount\tryindex
\newif\ifprime
\newif\ifagain
\newcommand\getprime[1]{%
  \opcopy{2}{P0}%
  \opcopy{3}{P1}%
  \opcopy{5}{try}
  \primeindex=2
  \loop
  \ifnum\primeindex<#1\relax
    \testprimality
    \ifprime
      \opcopy{try}{P\the\primeindex}%
      \advance\primeindex by1
    \fi
    \opadd*{try}{2}{try}%
    \ifnum\primeindex<#1\relax
      \testprimality
      \ifprime
        \opcopy{try}{P\the\primeindex}%
        \advance\primeindex by1
      \fi
      \opadd*{try}{4}{try}%
    \fi
  \repeat
}
\newcommand\testprimality{%
  \begingroup
    \againtrue
    \global\primetrue
    \tryindex=0
    \loop
      \opidiv*{try}{P\the\tryindex}{q}{r}%
      \opcmp{r}{0}%
      \ifopeq \global\primefalse \againfalse \fi
      \opcmp{q}{P\the\tryindex}%
      \ifoplt \againfalse \fi
      \advance\tryindex by1
    \ifagain
    \repeat
  \endgroup
}

With this code, we can create a prime numbers list (here the 20~first
ones).
\begin{SideBySideExample}
  \getprime{20}%
  \opprint{P0}, \opprint{P1}, \ldots,
  \opprint{P9}, \ldots \opprint{P19}.
\end{SideBySideExample}

Note that this code is very bad: it is very slow and don't give
anything against native \TeX{} operations. It is only an educational
example. Note also that the tricks to put loop into loop with macro
\verb+\testprimality+ inside a group. \package{xlop} operations give
global results.\index{global allocation}

Once you have your prime numbers ``table'', you can use it to
write a number as product of prime number.
\begin{CenterExample}[xrightmargin=0pt]
  \newcommand\primedecomp[2][nil]{%
    \begingroup
      \opset{#1}%
      \opcopy{#2}{NbtoDecompose}%
      \opabs{NbtoDecompose}{NbtoDecompose}%
      \opinteger{NbtoDecompose}{NbtoDecompose}%
      \opcmp{NbtoDecompose}{0}%
      \ifopeq
        I refuse to factorize zero.
      \else
        \setbox1=\hbox{\opdisplay{operandstyle.1}%
            {NbtoDecompose}}%
        {\setbox2=\box2{}}%
        \count255=1
        \primeindex=0
        \loop
        \opcmp{NbtoDecompose}{1}\ifopneq
          \opidiv*{NbtoDecompose}{P\the\primeindex}{q}{r}%
          \opcmp{0}{r}\ifopeq
            \ifvoid2
              \setbox2=\hbox{%
                \opdisplay{intermediarystyle.\the\count255}%
                  {P\the\primeindex}}%
            \else
              \setbox2=\vtop{%
                \hbox{\box2}
                \hbox{%
                  \opdisplay{intermediarystyle.\the\count255}%
                    {P\the\primeindex}}}
            \fi
            \opcopy{q}{NbtoDecompose}%
            \advance\count255 by1
            \setbox1=\vtop{%
              \hbox{\box1}
              \hbox{%
                \opdisplay{operandstyle.\the\count255}%
                  {NbtoDecompose}}
            }%
          \else
            \advance\primeindex by1
          \fi
        \repeat
        \hbox{\box1
          \kern0.5\opcolumnwidth
          \opvline(0,0.75){\the\count255.25}
          \kern0.5\opcolumnwidth
          \box2}%
      \fi
    \endgroup
  }

  \getprime{20}%
  \primedecomp[operandstyle.2=\red,
               intermediarystyle.2=\red]{252}
\end{CenterExample}
Note the use of group for the whole macro in order to protect
\package{xlop} parameter modifications.%
\index{parameter!local modification} Note also that void parameter
aren't allowed. It's not a bug, it's a feature. Author thinks that a
user who write brackets without anything between these brackets is
going to make a mistake. To obviate this
prohibition\index{parameter!void}, there is the particular
parameter \parameter{nil} which has exactly this rôle.
\index{loop|)}

Finally, note the trick \verb+{\setbox2=\box2}+ to obtain a void box
register, and final manipulations to show the vertical rule in a
easy-to-read way.

The second example allow to calculates a continued fraction like:
\def\dfrac#1#2{\frac{\displaystyle #1}{\displaystyle #2}}
\[a_0+\dfrac{1}{a_1+\dfrac{1}{a_2+\dfrac{1}{a_3+\cdots}}}\]
giving the sequence  $a_0,a_1,a_2,a_3,\ldots$ to the macro. This
example gives fractions corresponding to gold number, and square root
for~2 and~3.
\makeatletter
\begin{CenterExample}[xrightmargin=0pt]
  \begingroup
  \long\gdef\continuedfraction#1#2{%
    \let\@mirror\relax
    \@for\op@Nb:=#1\do
    {%
      \ifx\@mirror\relax
        \edef\@mirror{\op@Nb}%
      \else
        \edef\@mirror{\op@Nb,\@mirror}%
      \fi
    }%
    \let\Op@result\relax
    \@for\op@Nb:=\@mirror\do
    {%
      \ifx\Op@result\relax
        \opcopy{\op@Nb}{result}%
      \else
        \opexpr{\op@Nb+1/result}{result}%
      \fi
    }%
    \opcopy{result}{#2}%
  }
  \endgroup
  \continuedfraction{1,1,1,1,1,1,1,1,1,1,1,1}{r}\opprint{r}\quad
  \continuedfraction{1,2,2,2,2,2,2,2,2,2,2,2}{r}\opprint{r}\quad
  \continuedfraction{1,1,2,1,2,1,2,1,2,1,2,1}{r}\opprint{r}
\end{CenterExample}
\makeatother
It does no harm just this once, we use \LaTeX{} commands for the
loop.

\section{Direct Access to Number}
\label{sec:Acces direct aux nombres}
When a number is saved in a \package{xlop} variable, it is possible to
process with it in many different ways. However, in certain
situations, you would creat you own macro or use external macro giving
such numbers as parameter.

Giving directly \verb+\opprint{var}+ is ineffective since this macro
is a complex a gives side effect. It is necessary to access directly
to this number. When a variable hold a number, \package{xlop} creates
a macro
\texttt{$\backslash$Op@var}\index{Opvar@\texttt{\boi {Op\at var}}}
which contain this number. Note the uppercase ``O'' and the lowercase
``p''. The at sign is here to do this definition a private one, that
is, you have to enclose it with \macro{makeatletter} and
\macro{makeatother} to access it (or \macro{catcode @=11} in \TeX).
\begin{SideBySideExample}
  \opcopy{1234}{a}\opcopy{56}{b}%
  \opmul*{a}{b}{r}%
  \makeatletter
  \newcolumntype{.}{D{.}{.}{-1}}
  \begin{tabular}{l.}
             & \Op@a \\
    $\times$ & \Op@b \\
    $=$      & \Op@r
  \end{tabular}
  \makeatother
\end{SideBySideExample}

Note that this way of doing don't work when decimal separator is
between braces since macro \verb+\opprint{var}+ contain such
braces. In this case, the simplest is to use \macro{opexport} macro
(see page~\pageref{macro-opexport}).

\chapter{Future Versions}
\label{chap:Versions futures}
Version of \package{xlop} package is~\fileversion{} which is only a
debuging version of version~0.2, which is itself a correcting version
of version~0.1 (first public release). The next release will be
version~0.3 and its ``stable'' version will be version~0.4.

The features of version~0.3 aren't definitively fixed but there are
some points planned:
\begin{itemize}
\item international version for posées;
\item opérations from 2 to 36~basis;
\item additional high level functions with roots (\macro{oproot} for
  any roots and \macro{opsqrt} for square root), exponential function,
  logarithm, trigonometric functions (direct, inverse, hyperbolic);
\item macro to have a formated writing, that is, write a number where
  length of decimal part and integer part are given (if these widths
  are not the ones of the number, there will be overflow or filling);
  this macro was present in version~0.1 and allow to display numbers
  decimal aligned, right aligned, or left aligned;
\item parameter for scientific or engineer notation;
\item macro to allow to write a multi-line number and/or with thousand
  separator;
\item carries for multiplications;
\item make public the successive remainders of a division;
\item negative values of \parameter{maxdivstep} and
  \parameter{safedivstep} parameters will take acount of decimal digit
  of quotient.
\end{itemize}

For all requests or bug report, the author will be grateful to you to
contact him at:
\begin{verbatim}
    Jean-Come.Charpentier@wanadoo.fr
\end{verbatim}
placing the word ``xlop'' in the subject in order to help my spam killer.

It would be nice to have a hacker manual which explain in details the
source. This tool could be usefull in order to improve
\package{xlop}. Unfortunately, the current code has more
than~4000~lines and the work to do that may well be too long.

%\printindex
\chapter{Index}
\label{chap:index}
\begin{multicols}{2}
\makeatletter
\parindent \z@\relax
\parskip \z@ \@plus.3\p@\relax
\let\item\@idxitem
\makeatother
\renewenvironment{theindex}{}{}%
\input\jobname.ind
\end{multicols}
\end{document}
